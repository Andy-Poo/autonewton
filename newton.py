#!/usr/bin/env python

"""
newton - a smart bot, like Siri, for Slack chat rooms.
Copyright (C) 2019  Andy Poo

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License (LGPL) as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

See <http://www.gnu.org/licenses/> for a description of the LGPL.
"""

# flags for turning on debugging diagnostics
debug = False
debug2 = False

# location of where you are storing output generated by the bot
#botlog = '/tmp/bot.log'
botlog = '/home/andy/log/bot.log'

# this horrible hack is to make Python 2 behave properly with UTF-8 characters
import sys
reload(sys)  # Reload does the trick!
sys.setdefaultencoding('UTF8')

# these are all the modules we need
import pprint
import os
import time
import re
import subprocess
import math
import random
import threading
import Queue
import urllib2
from BeautifulSoup import BeautifulSoup

# seed the random number generator
random.seed()

try:
    from slackclient.slackclient import SlackClient
except ImportError as e:
    print e

try:
    import wikipedia
except ImportError as e:
    print e

# this is used by the "Animal Game"
import animal

# this mess is used by a game to print a rolled dice using ASCII art
dice = [
# 1
"\
===\n\
=0=\n\
===",
# 2
"\
===\n\
0=0\n\
===",
# 3
"\
===\n\
000\n\
===",
# 4
"\
0=0\n\
0=0",
# 5
"\
0=0\n\
=0=\n\
0=0",
# 6
"\
000\n\
000"
]

#appName = os.path.basename(sys.argv[0])

from wikipedia import Wikipedia
from wiki2plain import Wiki2Plain

# this is my funny bot conversation interface
import eliza

# set your time format to your preference
time_format = '%a %Y/%m/%d %H:%M:%S'

# this is the set of rules we use in our autonewton.com chat room on Slack
rules = \
r"""
*(1)* Bullying and baiting people is not tolerated.
If you do this, you might get kicked from the chatroom by a moderator.
If you continue to cause trouble, we may revoke your account.

*(2)* Foul language *IS* tolerated. We cannot stop you from swearing, nor do we care if you swear.
Some words are considered offensive and if you use them, you will get a warning from Slackbot
that the word is considered offensive.

*(3)* We encourage people to welcome the newcomer to the room.
We want new people to come back and they may be in need of assistance, so please focus on them.
We consider the newcomer the most important person in the room.

*(4)* Talking behind people's back is discouraged.
Unlike Parachat, when you logout, you can see what was said in the room when you return, simply by scrolling back.
THE CHATROOM HISTORY IS NEVER DELETED.
If you said something negative about someone, don't be surprised if they become angry with you.

*(5)* Discussion about religion and politics often causes arguments.
We won't stop you from discussing it but if it regresses into an argument, don't be surprised if you get kicked.
We recommend you avoid these subjects.

*(6)* *BEING TRIGGERED*: `if you are being triggered LEAVE`.
We're not all going to change what we're talking about to satisfy YOU.

*(7)* We will not call the authorities on people who are in crisis, even if they say they are going to harm themselves.
This chat room is not a professional service.

*(8)* We believe we can all act as adults, so please use some manners and respect when speaking with other chatters.
We should be able to police ourselves.

This website is not affiliated with any religion.
We are not a Christian chat room. We do not care what you believe.
People with no beliefs are welcome too.
"""

# this is the manual page the user can call up from Slack chat room
bot_help = r"""
Hi! I'm your bot, Newton!

I can perform several functions for you.
These are my commands:

!help - Get this page.
!rules - Get a list of the chat room rules

!bot - This command.
    !bot ping - See if the bot is alive.
    !bot date,!bot time - See what time it is where the bot is located.
    !bot uptime - See how long the bot has been up.

!bing, !b - Get the 3 top links for a subject.
!google, !g - Get the 3 top links for a subject.
    !b what is a bitcoin?

!wiki - Get a Wikipedia article on a subject.
    !wiki san francisco

!youtube, !y - Get the top 3 videos for a subject.
    !y madonna, vogue

!lyrics, !lyric, !l - Get the song lyrics for a song.
    Must be in the format:
        !lyrics artist=song
        !lyrics the beatles=eleanor rigby

!weather, !w - Get the weather for a city in the World.

!calendar, !cal - Get a calendar for a month.
    !cal dec
    !cal 1962 03

!joke - Get a Dad joke.

!math - Perform a math calculation.

!units, !u - Do unit conversions.
    !u ounce gram
    !u tempC(-24.5) tempF

!distance, !dist -
    Distance in a straight line between two towns.
    The two towns must be separated by a semicolon:
    !dist ottawa;melbourne
    !dist new york; los angeles

!date,!time - Get the date and time where you are located.
    !date @jommie - Get the date and time where Jommie lives.

!dt - Compute date and time differences.
    !dt 2018/12/24 13:05 now

!dice - Roll a dice.
!random, !rand - Pick a random number in a range:
    !rand 10 20
    !rand 100

!649 - Pick the six Lotto 6/49 numbers.

!hug, !hugs - Hug someone.
    !hug cher
    !hug @cher

!mobile - Information on getting Slack on mobile devices.
!apps - Information on getting Slack on desktop computers.
!beta - Information on getting the Beta releases of Slack.

!motd - Get the Message Of The Day.

!happy - Get Happy Message.

You can also talk to me. Start your lines with @newton. Eg:
@newton hello
newton APP [07:11]
Welcome ALL to autonewton.com

On a keyboard, you can quickly invoke someone's name
by typing the first three or four letters of their name
and pressing the Tab key. This is known as "Tab completion".
This will put an at sign (@) in front of someone's nick name.
If they have the desktop Slack app installed or they have
the mobile Slack app installed on their mobile device,
they will be notified by a "ding".


Commands must begin with an exclamation mark in the first column.
For tips about this chat program see:
http://autonewton.com/index.php/chat
"""

# some of the bot commands.
# all bot command begin with an exclamation mark, for example,
# !rules
responses = {
'rules': rules,
'mobile': r"Slack has a great mobile app for iPhones and Androids. For iPhones, go the Apple App Store. For Androids, go to the Google Play Store. Both apps are free downloads. You can also get them here: https://slack.com/downloads/",
'apps': r"You can download the free Slack app for your computer at: https://slack.com/downloads/",
'beta': "These are the beta versions of Slack where you can try out the latest features.\nThis version may have bugs and if you find any please contact Slack support by typing, /feedback <your message> at the start of a new line.\n\nWindows: https://slack.com/beta/windows\n\nmacOS: https://slack.com/beta/osx\n\nAndroid: https://slack.com/beta/android\n\niOS (iPhones and iPads): https://slack.com/beta/ios\n\nLinux: https://slack.com/downloads/linux"
}


# code for escaping html URLs
from xml.sax.saxutils import escape, unescape
# escape() and unescape() takes care of &, < and >.
html_escape_table = {
    '"': "&quot;",
    "'": "&apos;",
    " ": "%20"
}
html_unescape_table = {v:k for k, v in html_escape_table.items()}

def html_escape(text):
    return escape(text, html_escape_table)

def html_unescape(text):
    return unescape(text, html_unescape_table)


# regular expression pattern for finding a user name mention in the
# string being sent from a user to the bot
pat1 = re.compile(r"<@(.*)>")

# constants
RTM_READ_DELAY = 1 # 1 second delay between reading from RTM
MENTION_REGEX = "^<@(|[WwUu].+?)>(.*)"
MENTIONR_REGEX = "(.*)<@(|[WwUu].+?)>"


def find_nick(user_id, users):
    """Find the nickname (username) of a user by Slack user ID.

    user_id : str
        the Slack user ID.
    users : list
        the Slack list of members

    Returns:
        str : The user's nickname.
    """
    nick = "autonewton"
    ids = []
    for u in users:
        ids.append(u['id'])
    if user_id in ids:
        for u in users:
            if user_id == u['id']:
                nick = u['profile']['display_name']
                break
    return nick

def replace_mentions(text, users):
    """Replace "mentions" like @andy with the user's nickname.

    text : str
        the text to search
    users : list
        the Slack list of members

    Returns:
        str : the substituded text
    """
    if debug: print 'replace_mentions: text=', text
    while True:
        match = re.search(MENTIONR_REGEX, text)
        if not match:
            break
        username = match.group(2)
        #text = match.group(1)
        nick = find_nick(username, users)
        text = text.replace("<@%s>" % username, nick)
    if debug: print 'replace_mentions: new text=', text
    return text

import math
import operator
ops = {'+':operator.add,
       '-':operator.sub,
       '*':operator.mul,
       '/':operator.div,
       '^':operator.pow,
       'sin':math.sin,
       'tan':math.tan,
       'cos':math.cos,
       'pi':math.pi}

def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        pass

def rp_calculate(equation):
    """Reverse Polish Notation calculator
    based on http://en.wikipedia.org/wiki/Reverse_Polish_notation

    equation : str
        A string to interpret as a Reverse Polish mathematical statement.

    Returns:
        str : The result in ASCII text.
    """
    stack = []
    result = 0
    for i in equation.split(' '):
        if is_number(i):
            stack.insert(0,i)
        else:
            if len(stack) < 2:
                #print 'Error: insufficient values in expression'
                return 'Error: insufficient values in expression'
                break
            else:
                #print 'stack: %s' % stack
                if len(i) == 1:
                    n1 = float(stack.pop(1))
                    n2 = float(stack.pop(0))
                    result = ops[i](n1,n2)
                    stack.insert(0,str(result))
                else:
                    n1 = float(stack.pop(0))
                    result = ops[i](math.radians(n1))
                    stack.insert(0,str(result))
    return '%.2f' % result

# this class handles background processing of web requests
class NewtonThread(threading.Thread):
    """
    This class implements the background thread used by the bot.
    """
    def __init__(self):
        # this flag controls termination of the thread
        self.die = False
        # the queue ID is for tracking requests being queued.
        # it is not currently needed but is useful for debugging purposes.
        self.qid = 0
        # the input queue and output queue are thread-safe queues for
        # enqueuing web requests and dequeuing web responses
        self.iqueue = Queue.Queue()
        self.oqueue = Queue.Queue()
        # initialize the parent instance
        super(NewtonThread, self).__init__()

    def kill(self):
        """Kill an instance of the NewtonThread thread.
        """
        print 'NewtonThread::kill'
        self.die = True

    def enqueue(self, cmd, arg, method='html'):
        """Enqueue a command to execute by the thread

        cmd : method
            The method that will be executed later.
        arg : str or other type
            The argument that will be passed to the method.
        method : str
            The type of web request that is desired.
            Values can be 'html', 'plain', 'json'.

        Returns:
            int : The queue ID of this new enqueued entry.
        """
        if debug: print 'NewtonThread::enqueue: cmd=', cmd
        if debug: print 'NewtonThread::enqueue: arg=', arg
        if debug: print 'NewtonThread::enqueue: method=', method
        self.qid += 1
        self.iqueue.put((self.qid, cmd, arg, method,))
        if debug: print 'NewtonThread::enqueue: qid=', self.qid
        return self.qid

    def dequeue(self):
        """Dequeue the result of a web request that was enqueued earlier
        and call the method name that was passed

        Returns:
            str : The response from the command.
        """
        #print 'NewtonThread::dequeue'
        # if the queue is empty, just return
        if self.isempty():
            return None
        # get the web result from the output queue
        item = self.oqueue.get()
        # retrieve the qid, the command and the web content from the item
        (qid, cmd, content) = item
        if debug: print 'NewtonThread::dequeue: qid=', qid
        if debug: print 'NewtonThread::dequeue: cmd=', cmd
        if debug2: print 'NewtonThread::dequeue: content=', content
        # call the command that was passed in by name
        response = cmd(content)
        if debug2: print 'NewtonThread::dequeue: response:\n', response
        # return the result of the command
        return response

    def isempty(self):
        """Is the output queue empty?

        Returns:
            True if the queue is empty.
        """
        return self.oqueue.empty()

    def webrequest(self, url, method='html'):
        """Perform a web request to a web server in the thread background.

        url : str
            The URL of the web server to call.
        method : str
            The type of web request that is desired.
            Values can be 'html', 'plain', 'json'.

        Returns:
            str : The content text returned from the web server.
        """
        if debug: print 'NewtonThread::webrequest: url=', url
        if debug: print 'NewtonThread::webrequest: method=', method
        method_type = 'text/html'
        if method == 'plain':
            method_type = 'text/plain'
        elif method == 'json':
            method_type = 'application/json'
        # 2019/01/16 (AJE): this is a hack but works for my needs for now
        return_tuple = False
        if isinstance(url, tuple) or isinstance(url, list):
            # the url will have been stored in the first entry in the list or tuple
            # and the remaining arguments will be returned in a tuple in the content
            args = url[1:]
            url = url[0]
            return_tuple = True
        else:
            args = (None,)
        request = urllib2.Request(url)
        request.add_header('Accept', method_type)
        request.add_header('User-Agent', 'Mozilla/5.0')
        try:
            # try for up to 10 seconds to get a response
            result = urllib2.urlopen(request, timeout=10).read()
        except Exception as e:
            result = 'Error: %s\n%s\n' % (str(e), url)
            print 'NewtonThread::webrequest:', result
            result = None
        if return_tuple:
            return (result,) + args
        return result

    def run(self):
        """
        This method runs in the background thread.
        Anything you run in here runs parallel with the main thread.
        """
        # self.die :
        # when this flag is set, the run method exits and this
        # causes this thread to terminate.
        # Note: it is very important to terminate the thread
        # before aborting the main thread or it will hang
        # indefinitely waiting for this thread to exit.
        while not self.die:
            try:
                # non-blocking wait
                item = self.iqueue.get(False)
            # is the queue empty?
            except Queue.Empty:
                item = None
                # you might want to fine tune this sleep time
                time.sleep(0.1)
            # did we get an item from the queue?
            if item is not None:
                # pull the values from the item
                (qid, cmd, arg, method) = item
                if debug: print 'NewtonThread::run: qid=', qid
                if debug: print 'NewtonThread::run: cmd=', cmd
                if debug: print 'NewtonThread::run: arg=', arg
                if debug: print 'NewtonThread::run: method=', method
                # FIXME: for now all commands are web requests
                url = arg
                content = self.webrequest(url, method)
                if debug2: print 'NewtonThread::run: content=', content
                if content:
                    # enqueue the web result in the output queue
                    self.oqueue.put((qid, cmd, content,))


##############
# MAIN CLASS #
##############

class Newton:
    """
    This class implements the bot.
    """
    def __init__(self):
        # obtain the slack client via newton.sh which you need to modify for your installation
        self.slack_client = SlackClient(os.environ.get('SLACK_BOT_TOKEN'))
        # starterbot's user ID in Slack: value is assigned after the bot starts up
        self.starterbot_id = None
        # this is the Slack channel we are communicating on
        self.channel = None
        # this is the list of Slack users
        self.users = None
        # this is time in UNIX time_t when the bot started up
        self.time0 = 0
        # this is a counter for the animal game
        self.countdown = 0
        self.distanceQuery1 = ''
        self.distanceQuery2 = ''
        # this is the instance of the thread we will use for background web requests
        self.newtonThread = NewtonThread()
        # start the background thread running
        self.newtonThread.start()

    def __del__(self):
        """When this class instance is deleted, kill the background thread.
        """
        self.newtonThread.kill()

    def slack(self):
        """This is the main method which stays running until the bot is terminated.
        """
        self.time0 = time.time()
        animal.animal_load()
        self.countdown = 0
        if self.slack_client.rtm_connect(with_team_state=False):
            print time.strftime('%Y/%m/%d %H:%M:%S', time.localtime(self.time0))
            #print("Starter Bot connected and running!")
            print "APP Newton: Slack bot STARTED"
            # Read bot's user ID by calling Web API method `auth.test`
            self.starterbot_id = self.slack_client.api_call("auth.test")["user_id"]

            if debug: print 'Newton::slack: starterbot_id=', self.starterbot_id

            # get this list of Slack users
            user_list = self.slack_client.api_call("users.list")
            #pp = pprint.PrettyPrinter(indent=4)
            #pp.pprint(user_list)
            self.users = []
            for u in user_list["members"]:
                self.users.append(u)
            #pp.pprint(self.users)

            # run forever until the bot is terminated
            while True:
                #print 'Newton::slack: parse bot commands'
                command, channel = self.parse_bot_commands(self.slack_client.rtm_read())
                if debug2: print 'Newton::slack: command, channel=', command, self.channel
                if channel:
                    # save the channel for dequeuing messages
                    self.channel = channel
                if self.channel:
                    if self.countdown == 0:
                        if debug:
                            # random interval between 30 and 120 seconds
                            low = 30
                            high = 120
                        else:
                            # random interval between 5 and 30 minutes
                            low = 60*5
                            high = 60*20
                        self.countdown = random.randint(low, high)
                        if debug: print 'Newton::slack: countdown=', self.countdown
                        reply = animal.animal_game()
                        self.post_message(self.channel, reply)
                    self.countdown -= 1
                    tm = time.localtime()
                    if debug2: print 'Newton::slack: tm=', time.asctime(tm)
                    # is it the top of the hour (or top of the minute if debug)
                    if tm.tm_sec == 0 and (debug or tm.tm_min == 0):
                        if debug: print 'Newton::slack: chime'
                        reply = animal.animal_game_chime()
                        self.post_message(self.channel, reply)
                        # save the database often
                        animal.animal_dump()
                        
                if command:
                    # process the command
                    reply = self.handle_command(command, self.channel)
                    if debug2: print 'Newton::slack: reply=', reply
                    if reply:
                        # send a message back to the Slack channel
                        self.post_message(self.channel, reply)

                # process any results of web requests that were queued up for processing
                while True:
                    reply = self.newtonThread.dequeue()
                    if debug2: print 'Newton::slack dequeue: reply:\n', reply
                    if not reply:
                        break
                    # Sends the reply back to the channel
                    self.post_message(self.channel, reply)
                # be nice and don't hog the CPU
                time.sleep(RTM_READ_DELAY)
        else:
            print("Newton::slack: Connection failed. Exception traceback printed above.")

    def post_message(self, channel, text):
        """Post a message in the Slack channel.

        channel : str
            The Slack channel identifier (eg, #general).
        text : str
            The string to print in the channel.
        """
        if debug: print 'Newton::post_message: channel=', channel
        if debug2: print 'Newton::post_message: text:\n', text
        if text:
            # Sends the reply back to the channel
            self.slack_client.api_call(
                "chat.postMessage",
                channel=channel,
                text=text
            )

    def handle_command(self, command, channel):
        """Executes bot command if the command is known.

        command : str
            The command string to execute.
        channel:
            The Slack channel.
        """
        # Default response is help text for the user
        #default_response = "COMMAND UNKNOWN"

        response = command

        # Finds and executes the given command, filling in response
        #response = None
        # This is where you start to implement more commands!

        # Sends the response back to the channel
        self.post_message(channel, response)

    def members(self, user_id=None):
        """Get a list of Slack members.

        user_id : str
            the Slack user ID.

        Returns:
            str : human-readable list of members
        """
        result = ''
        for u in self.users:
            #pp = pprint.PrettyPrinter(indent=4)
            #pp.pprint(u)
            if user_id is None or u['id'] == user_id:
                uid = u['id']
                nick = u['name']
                is_admin = False
                if 'is_admin' in u:
                    admin = u['is_admin']
                tz_lable = ''
                if 'tz_label' in u:
                    tz_label = u['tz_label']
                name = ''
                if 'display_name' in u['profile']:
                    name = u['profile']['display_name']
                status_emoji = ''
                if 'status_emoji' in u['profile']:
                    status_emoji = u['profile']['status_emoji']
                status_text = ''
                if 'status_text' in u['profile']:
                    status_text = u['profile']['status_text']
                email = ''
                if 'email' in u['profile']:
                    email = u['profile']['email']
                result += "\n`%s` : %s, Admin=%s, ID=%s, <%s> %s" % (
                    nick, name, admin, uid, tz_label, email)
                result += "\n    %s %s" % (status_emoji, status_text)
        return result

    def bing(self, query, youtube=False):
        """Perform a Bing lookup on bing.com

        query : str
            The query search string.
        youtube : bool
            True if doing a lookup for a YouTube video.

        Returns:
            str - The text result of the lookup.
        """
        from BingWebSearchv7 import Bing
        return Bing(query, youtube=youtube)

    def wiki(self, query):
        """Peform a Wikipedia lookup on wikipedia.com,
        returning the page identifier for a lookup by wikiurl.

        query : str
            The query search string.

        Returns:
            str : The result of the web page.
            int : The page identifier.
        """
        if debug: print 'Newton::wiki: query=', query
        result = None
        pageid = None

        #lang = 'simple'
        lang = 'en'
        wiki = Wikipedia(lang)

        try:
            content = wiki.article(query)
        except Exception as e:
            print 'Newton::wiki: Error:', e
            content = None

        if content:
            #pp = pprint.PrettyPrinter(indent=4)
            #pp.pprint(content)

            try:
                # Warning: this is a potential security risk:
                d = eval(content)
                q = d['query']
                #print 'Newton::wiki: q=', q
                s = q['search']
                if s:
                    s = s[0]
                    #print '*'*40
                    #print 'wiki: s=', s
                    #print '*'*40
                    pageid = s['pageid']
                    #print 'wiki: pageid=', pageid
                    #title = s['title']
                    snippet = s['snippet']
                    wiki2plain = Wiki2Plain(snippet)
                    snippet = wiki2plain.text
                    snippet = html_unescape(snippet)
                    #pp = pprint.PrettyPrinter(indent=4)
                    #pp.pprint(snippet)
                    stripped = snippet.replace('\\\\', '\\')
                    # Warning: this is a potential security risk:
                    string = eval("u'" + stripped + "'")
                    result = string
            except Exception as e:
                print 'Newton::wiki: Error:', e
                return (None, None)

        return (result, pageid)

    def wikiurl(self, pageid):
        """Perform a Wikipedia lookup given the page identifier.

        pageid : int
            The Wikipedia page identifier.

        Returns:
            str - The URL used for the lookup.
        """
        if debug: print 'Newton::wikiurl: pageid=', pageid

        url = 'https://en.wikipedia.org/w/api.php?action=query&prop=info&pageids=%d&inprop=url&format=json' % pageid
        #print 'Newton::wikiurl: url=', url
        #lang = 'simple'
        lang = 'en'
        wiki = Wikipedia(lang)

        try:
            result = wiki.fetch(url)
            content = result.read()
        except Exception as e:
            print 'Newton::wikiurl: Error:', e
            content = None

        if content:
            #print 'Newton::wikiurl: content='
            #pp = pprint.PrettyPrinter(indent=4)
            #pp.pprint(content)

            try:
                # Warning: this is a potential security risk:
                d = eval(content)
                #print 'Newton::wikiurl: d=', d
                #count = 0
                #for c in d:
                #    print 'count=', count
                #    print 'c=', c
                #    count += 1
                #print 'count=', count
                q = d['query']
                #print 'Newton::wikiurl: q=', q
                url = q['pages'][str(pageid)]['fullurl']
            except Exception as e:
                print 'Newton::wikiurl: Error:', e
                return None

        #print 'Newton::wikiurl: url=', url
        return url

    def weather(self, query):
        """Perform a lookup for a weather report.

        query : str
            The location of the place for the report.
        """
        if debug: print 'Newton::weather: query=', query
        weather_api_key = os.environ.get('WEATHER_API_KEY')
        url = html_escape('https://api.openweathermap.org/data/2.5/weather?q=%s' % query)
        url += '&appid=%s' % weather_api_key
        #print 'Newton::weather: url=', url
        self.newtonThread.enqueue(self.weatherHandler, url)

    def weatherHandler(self, content):
        """The handles the weather report response that came back from the website.

        content : str
            The web content data to parse.

        Returns:
            str : The weather report.
        """
        if debug: print 'Newton::weatherHandler: content=', content
        lon = 0
        lat = 0
        description = ''
        temp = 0
        pressure = 0
        temp_min = 0
        temp_max = 0
        visibility = 0
        wind_speed = 0
        name = ''
        country = ''
        sunrise = 0
        sunset = 0
        try:
            # Warning: this is a potential security risk:
            values = eval(content)
            lon = values['coord']['lon']
            lat = values['coord']['lat']
            description = values['weather'][0]['description']
            temp = values['main']['temp']
            pressure = values['main']['pressure']
            temp_min = values['main']['temp_min']
            temp_max = values['main']['temp_max']
            visibility = values['visibility']
            wind_speed = values['wind']['speed']
            name = values['name']
            country = values['sys']['country']
            sunrise = values['sys']['sunrise']
            sunset = values['sys']['sunset']
        except Exception as e:
            print 'Newton::weatherHandler: Error:', e
            #return str(e)
        K = -273.15
        temp_c = temp + K
        temp_f = temp_c*9.0/5.0 + 32
        temp_min_c = temp_min + K
        temp_min_f = temp_min_c*9.0/5.0 + 32
        temp_max_c = temp_max + K
        temp_max_f = temp_max_c*9.0/5.0 + 32
        pressure_m = pressure/10.0
        pressure_i = pressure * 0.02953
        visibility_m = visibility/1000.0
        visibility_i = visibility_m * 0.621371
        wind_speed_m = wind_speed
        wind_speed_i = wind_speed_m * 0.621371
        #time_t = time.time()
        #diff = time.localtime(time.mktime(time_t)) - time.gmtime(time.mktime(time_t))
        #time_midnite = (t[0], t[1], t[2], 0, 0, 0, t[6], t[7], t[8],)
        #time_0 = (t[0], t[1], t[2], t[3], t[5], 0, t[6], t[7], t[8],)
        #diff = time.localtime(time_0) - time.localtime(time_midnite)
        #sunrise_t = time.localtime(sunrise)
        #sunrise = time.strftime('%H:%m', sunrise_t)
        result = 'Weather for %s, %s\n' % (name, country)
        result += '='*20 + '\n'
        result += 'Latitude=%.2f\n' % lat
        result += 'Longitude=%.2f\n' % lon
        result += 'Current Temperature: %.1fC/%.1fF\n' % (temp_c, temp_f)
        result += 'Minimum: %.1fC/%.1fF\n' % (temp_min_c, temp_min_f)
        result += 'Maximum: %.1fC/%.1fF\n' % (temp_max_c, temp_max_f)
        result += 'Pressure: %.1fkPa/%.1f inches\n' % (pressure_m, pressure_i)
        result += 'Visibility: %.1fkm/%.1f miles\n' % (visibility_m, visibility_i)
        result += 'Wind Speed: %.1fkm/%.1f miles\n' % (wind_speed_m, wind_speed_i)
        result += '%s\n' % description
        #result += 'Sunrise: %s\n' % sunrise
        #return (result, lat, lon)
        return result

    def distance(self, args):
        """Calculate the distance between any two cities by straight line disance

        query : str
            The locations of the two places for the report.
        """
        if debug: print 'Newton::distance: args=', args
        result = ''
        query = ''.join(args)
        if not query:
            return result
        if '=' in query:
            mysplit = query.split('=')
        elif ';' in query:
            mysplit = query.split(';')
        else:
            return result
        query1 = mysplit[0].strip()
        query2 = mysplit[1].strip()
        if debug: print 'distance: query1=', query1
        if debug: print 'distance: query2=', query2
        # this is needed for distanceHandler2
        self.distanceQuery1 = query1
        self.distanceQuery2 = query2
        weather_api_key = os.environ.get('WEATHER_API_KEY')
        url = html_escape('https://api.openweathermap.org/data/2.5/weather?q=%s' % query1)
        url += '&appid=%s' % weather_api_key
        self.newtonThread.enqueue(self.distanceHandler1, url)

    def distanceHandler1(self, content):
        """This handles the distance report response that came back from the weather website.

        content : str
            The web content data to parse.
        """
        if debug: print 'Newton::distanceHandler1: content=', content
        lon = 0
        lat = 0
        try:
            # Warning: this is a potential security risk:
            values = eval(content)
            lon = values['coord']['lon']
            lat = values['coord']['lat']
        except Exception as e:
            print 'Newton::distanceHandler1: Error:', e
            return None
        # the place name was stored in this attribute in method "distance"
        query2 = self.distanceQuery2
        weather_api_key = os.environ.get('WEATHER_API_KEY')
        url = html_escape('https://api.openweathermap.org/data/2.5/weather?q=%s' % query2)
        url += '&appid=%s' % weather_api_key
        item = (url, lat, lon,)
        self.newtonThread.enqueue(self.distanceHandler2, item)

    def distanceHandler2(self, content):
        """This handles the second distance report response that came back from the weather website.

        content : str
            A tuple containing the web content data to parse
            and the latitude and longitude values which were passed in by
            distanceHandler1
        """
        if debug: print 'Newton::distanceHandler2: content=', content
        # 2019/01/16 (AJE): this is how I handled passing the latitude and logitude
        # result back from the first call to the weather service API
        lat1 = content[1]
        lon1 = content[2]
        content = content[0]

        # get the result for the latitude and longitude from the second web request
        lon2 = 0
        lat2 = 0
        try:
            # Warning: this is a potential security risk:
            values = eval(content)
            lon2 = values['coord']['lon']
            lat2 = values['coord']['lat']
        except Exception as e:
            print 'Newton::distanceHandler2: Error:', e
            return None

        place1 = self.distanceQuery1
        place2 = self.distanceQuery2
        result = 'Distance between %s and %s is:\n' % (place1, place2)
        R = 6371e3      # metres
        phi1 = math.radians(lat1)
        phi2 = math.radians(lat2)
        delta_phi = math.radians(lat2 - lat1)
        delta_lambda = math.radians(lon2 - lon1)
        a = math.sin(delta_phi/2) * math.sin(delta_phi/2) + \
            math.cos(phi1) * math.cos(phi2) * \
            math.sin(delta_lambda/2) * math.sin(delta_lambda/2)
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
        dist = R * c
        result += '%.0f km (%.0f miles)' % (dist/1000.0, dist/1.609344/1000.0)
        return result

    def calculate(self, equation):
        """Perform a Reverse Polish math calculation.

        equation : str
            A string containing a mathematical expression.

        Returns:
            str : A string containing the result.
        """
        if debug: print 'Newton::calulate: equation=', equation
        return rp_calculate(equation)

    def find_time(self, user_id):
        """Find the time where a Slack member is located.

        user_id : str
            The Slack user ID.
        
        Returns:
            str - The formatted time at the member's location.
        """
        result = ""
        ids = []
        for u in self.users:
            ids.append(u['id'])
        if user_id in ids:
            for u in self.users:
                if user_id == u['id']:
                    tz_offset = u['tz_offset']
                    time_t = time.time()
                    time_gm = time.gmtime(time_t)
                    time_local = time.localtime(time_t)
                    localtime_t = time.mktime(time_local)
                    user_t = int(time_t) + int(tz_offset)
                    time_user = time.gmtime(user_t)
                    tz_diff = int(user_t - time_t)
                    tz_hours = tz_diff / (60*60)
                    sign = ''
                    if tz_diff >= 0:
                        sign = '+'
                    zone = '(UTC%s%.1f)' % (sign, tz_hours) 
                    result = time.strftime(time_format, time_user)
                    result += ' ' + zone
                    break
        return result

    def joke(self):
        """Get a Dad joke.
        """
        url = "https://icanhazdadjoke.com/"
        self.newtonThread.enqueue(self.jokeHandler, url, method='plain')

    def jokeHandler(self, content):
        """Process the Dad joke result that came back from the website.

        content : str
            The web content data to parse.

        Returns:
            str : The joke result.
        """
        if debug2: print 'Newton::jokeHandler: content=', content
        soup = BeautifulSoup(content)
        if debug2: print soup.prettify()
        text = soup.text
        return text

    def lyrics(self, args):
        """Get the lyrics for a song.

        args : str
            The artist and song title.

        Returns:
            str : The empty string.
        """
        result = ''
        query = ' '.join(args)
        if not query:
            return result
        if '=' in query:
            mysplit = query.split('=')
        elif ';' in query:
            mysplit = query.split(';')
        else:
            return result
        artist = mysplit[0].strip()
        song = mysplit[1].strip()
        url = "http://api.chartlyrics.com/apiv1.asmx/SearchLyric?Artist=%s&Song=%s" % (artist.replace(' ', '%20'), song.replace(' ', '%20'))
        self.newtonThread.enqueue(self.lyricsHandler1, url)

    def lyricsHandler1(self, content):
        """This is the first part of the lyrics handling.
        It does the lookup by artist and song title to obtain a unique identifier for the song.

        content : str
            The web content data to parse.

        Returns:
            str : The empty string.
        """
        if debug: print 'Newton::lyricsHandler1'
        result = ''
        xml = content
        soup = BeautifulSoup(xml)
        if debug: print soup.prettify()
        lyricid = soup.searchlyricresult.lyricid
        if hasattr(lyricid, 'string'):
            lyricid = soup.searchlyricresult.lyricid.string
            lyricchecksum = soup.searchlyricresult.lyricchecksum.string
            if debug: print 'Newton::lyricsHandler1: lyricid=', lyricid
            if debug: print 'Newton::lyricsHandler1: lyricchecksum=', lyricchecksum

            if lyricid and lyricchecksum:
                url = "http://api.chartlyrics.com/apiv1.asmx/GetLyric?lyricId=%s&lyricCheckSum=%s" % (lyricid, lyricchecksum)
                self.newtonThread.enqueue(self.lyricsHandler2, url)
        return result

    def lyricsHandler2(self, content):
        """This is the second part of the lyrics handling.
        It obtains the lyrics to the song, given the unique song identifier.

        content : str
            The web content data to parse.

        Returns:
            str : The lyric text obtained from the website.
        """
        if debug: print 'Newton::lyricsHandler2'
        xml = content
        soup = BeautifulSoup(xml)
        if debug: print soup.prettify()
        lyric = soup.getlyricresult.lyric.string
        if debug: print lyric
        result = lyric
        return result

    def parse_bot_commands(self, slack_events):
        """Parses a list of events coming from the Slack RTM API to find bot commands.
        If a bot command is found, this function returns a tuple of command and channel.
        If its not found, then this function returns None, None.

        slack_events : str
            The Slack event data to parse.

        Returns:
            str : the Slack channel identifier
            str : the text message that was typed into the chat room.
        """
        for event in slack_events:
            if debug2:
                print 'Newton::parse_bot_commands:'
                pp = pprint.PrettyPrinter(indent=4)
                pp.pprint(event)
            if event["type"] == "message" and not "subtype" in event:
                text = event["text"].encode('ascii', errors='ignore')
                if debug: print 'text=', text
                user = event["user"]
                if debug: print 'user=', user
                channel = event["channel"]
                if debug: print 'channel=', channel
                user_id, message = self.parse_direct_mention(text, user)
                #pp = pprint.PrettyPrinter(indent=4)
                #print "message="
                #pp.pprint(message)
                if debug2: print 'Newton::parse_bot_commands: user_id=', user_id
                if debug2: print 'Newton::parse_bot_commands: message=', message
                if user_id == self.starterbot_id:
                    match = re.search(MENTIONR_REGEX, message)
                    if match:
                        username = match.group(2)
                        text = match.group(1)
                        nick = find_nick(username, self.users)
                    else:
                        text = message
                        nick = 'ALL'
                    if 'joke' in text:
                        self.joke()
                        return None, None
                    message = eliza.analyze(nick, text)
                    if debug: print "Newton::parse_bot_commands: eliza message='%s'" % message
                    return message, channel
                else:
                    #try:
                    message = self.parse_command(text, user)
                    if debug: print 'Newton::parse_bot_commands: message=', message
                    if message is not None:
                        return message, channel
        return None, None

    def parse_direct_mention(self, message_text, user):
        """Finds a direct mention (a mention that is at the beginning) in message text
        and returns the user ID which was mentioned. If there is no direct mention, returns None.
        This is used by Newton to see if you are talking to him.

        message_text : str
            The text to be parsed.
        user : str
            The Slack user ID to search for.
        Returns:
            str : user ID.
            str : the message text.
        """
        matches = re.search(MENTION_REGEX, message_text)
        if debug: print 'Newton::parse_direct_mention: matches=', matches
        # the first group contains the username, the second group contains the remaining message
        return (matches.group(1), matches.group(2).strip()) if matches else (None, None)

    #__BEGIN__ commands
    def parse_command(self, text, user):
        """Finds a bang (!) command.

        text : str
            The command to parse.
        user : str
            The Slack user ID to search for.

        Returns:
            str : The result of the command.
        """
        global debug, debug2
        if debug: print 'Newton::parse_command: text, user=', text, user
        result = None
        if re.search("^!", text):
            words = text.split()
            tokens = []
            for word in words:
                w = word.strip()
                if w:
                    tokens.append(w)
            command = tokens[0][1:].lower()

            if command in responses:
                result = responses[command]

            elif command == 'help':
                result = bot_help

            elif command in ('members', 'member'):
                user_id = None
                if len(tokens) > 1:
                    token = tokens[1]
                    m = pat1.search(token)
                    if m:
                        user_id = m.group(1)
                result = self.members(user_id)

            elif command == 'joke':
                self.joke()

            elif command in ('lyrics', 'lyric', 'l'):
                self.lyrics(tokens[1:])

            elif command in ('bing', 'b', 'google', 'g', 'youtube', 'y'):
                query = ' '.join(tokens[1:])
                youtube = command in ('youtube', 'y')
                result = self.bing(query, youtube=youtube)

            elif command == 'wiki':
                query = ' '.join(tokens[1:])
                (result, pageid) = self.wiki(query)
                if result:
                    url = self.wikiurl(pageid)
                    if url:
                        result = url + '\n' + result

            elif command in ('hug', 'hugs'):
                token = tokens[1]
                m = pat1.search(token)
                if m:
                    user_id = m.group(1)
                    nick = find_nick(user_id, self.users)
                else:
                    nick = token
                result = "((( " + nick + " )))"

            elif command in ('date', 'time'):
                user_id = user
                if len(tokens) > 1:
                    token = tokens[1]
                    m = pat1.search(token)
                    if m:
                        user_id = m.group(1)
                result = self.find_time(user_id)

            elif command == 'math':
                try:
                    expression = ' '.join(tokens[1:])
                    # Warning: this is a potential security risk,
                    # but this is also the simplest way to evaluate
                    # an expression.
                    result = str(eval(expression))
                # if the command fails due to syntax error,
                # assume the syntax is in Reverse Polish Notation.
                except Exception as e:
                    try:
                        result = self.calculate(expression)
                    # and if that fails, the guy is a idiot.
                    except Exception as e:
                        # so tell him what he did wrong.
                        print 'Newton::parse_command: Error:', e
                        result = str(e)

            elif command in ('weather', 'we', 'w'):
                query = ' '.join(tokens[1:])
                self.weather(query)

            elif command in ('distance', 'dist'):
                query = ' '.join(tokens[1:])
                self.distance(query)

            elif command in ('units', 'unit', 'u'):
                #query = ' '.join(tokens[1:])
                query = ''
                for token in tokens[1:]:
                    query += '"' + token + '"' + ' '
                #print 'units: query=', query
                try:
                   result = subprocess.check_output(
                       '/usr/bin/units -q %s' % query,
                       stderr=subprocess.STDOUT,
                       shell=True)
                except Exception as e:
                    print 'units: Error:', e
                    result = str(e)
                #print 'units: result=', result

            elif command in ('dice', 'random', 'rand'):
                myrange = None
                result = None
                if command == 'dice':
                    dice_count = 1
                    mytokens = tokens[1:]
                    #print 'mytokens=', mytokens
                    if len(mytokens) >= 1:
                        try:
                            dice_count = int(mytokens[0])
                        except Exception as e:
                            print e
                            dice_count = 1
                        # to prevent room spam
                        if dice_count > 5:
                            dice_count = 5
                    #print 'dice_count=', dice_count
                    result = ''
                    for i in range(dice_count):
                        roll = random.randint(0, 5)
                        result += '%d\n' % (roll+1)
                        result += dice[roll]
                        result += '\n\n'
                else:
                    error = True
                    mytokens = tokens[1:]
                    if len(mytokens) == 0:
                        result = str(random.random())
                    elif len(mytokens) == 1:
                        try:
                            error = False
                            myend = int(mytokens[0])
                        except:
                            myend = 10
                        myrange = range(1, myend+1)
                    elif len(mytokens) == 2:
                        try:
                            error = False
                            mystart = int(mytokens[0])
                            myend = int(mytokens[1])
                        except:
                            mystart = 1
                            myend = 10
                        myrange = range(mystart, myend+1)
                    if error:
                        myrange = mytokens
                if myrange is not None:
                    if not result:
                        result = str(random.choice(myrange))

            elif command == 'dt':
                from dt import dt
                expression = ' '.join(tokens[1:])
                time_x = dt(expression)
                if time_x:
                    time_d = time_x / (60*60*24.)
                    time_y = time_d / 365.25
                    time_h = int(time_x / (60*60))
                    time_s = time_x % 60
                    time_m = abs(int(time_x - time_h*60*60 - time_s)/60)
                    result = '%.1f years\n' % time_y
                    result += '%.1f days\n' % time_d
                    result += '%d : %02d : %02d hours\n' % (time_h, time_m, time_s)
                    result += "%d seconds\n" % time_x
                else:
                    result = "invalid date format or date out of range"

            elif command in ('calendar', 'cal'):
                tm_year = time.localtime().tm_year
                query = ' '.join(tokens[1:])
                if query:
                    if query.isdigit() or query.isalpha():
                        query += ' %d' % tm_year
                #print 'calendar: query:', query
                try:
                   result = subprocess.check_output(
                       '/usr/bin/cal %s' % query,
                       stderr=subprocess.STDOUT,
                       shell=True)
                except Exception as e:
                    print 'cal: Error:', e
                    result = 'cal syntax error'
                # remove highlighted day
                result = result.replace('_', '')
                # remove garbage setlocale line
                lines = ''
                for line in result.split('\n'):
                    #print 'line=', line
                    if 'setlocale' not in line:
                        lines += line + '\n'
                result = lines
                #TBD: ugh, Slack uses proportional fonts
                result = result.replace(' ', '=')

            elif command == '649':
                result = ''
                numbers = []
                count = 0
                number = 0
                while count < 6:
                    number = random.randint(1, 49)
                    if number not in numbers:
                        numbers.append(number)
                        result += '| %d ' % number
                        count += 1
                result += '|'

            elif command in animal.animal_commands:
                query = ' '.join(tokens[1:])
                nickname = find_nick(user, self.users)
                query = replace_mentions(query, self.users)
                result = animal.animal_command_handler(nickname, command, query)

            elif command == 'bot':
                if len(tokens) < 2:
                    result = bot_help
                else:
                    bot_command = tokens[1]
                    if bot_command == 'ping':
                        result = "I'm alive!"
                    elif bot_command in ('debug', 'debug2', 'off'):
                        if bot_command == 'debug2':
                            debug = debug2 = True
                        elif bot_command == 'debug':
                            debug = True
                            debug2 = False
                        elif bot_command == 'off':
                            debug = False
                            debug2 = False
                    elif bot_command in ('version', 'ver'):
                        from version import version
                        result = version()
                    elif bot_command in ('quit', 'kill'):
                        # save the animal stats before exiting
                        animal.animal_dump()
                        self.newtonThread.kill()
                        sys.exit(0)
                    elif bot_command == 'log':
                        # print the log file
                        result = ''
                        try:
                            fd = open(botlog, 'r')
                        except Exception as e:
                            result = str(e)
                            fd = None
                        if fd:
                            for line in fd:
                                result += line.strip() + '\n'
                            fd.close()
                    elif bot_command == 'clear':
                        # terminate the log file
                        try:
                            fd = open(botlog, 'w')
                        except Exception as e:
                            result = str(e)
                            fd = None
                        if fd:
                            fd.close()
                    elif bot_command == 'sleep':
                        mytokens = tokens[2:]
                        value = 0
                        if len(mytokens) >= 1:
                            #print 'bot sleep: mytokens=', mytokens
                            try:
                                value = int(mytokens[0])
                            except Exception as e:
                                print 'bot sleep: Error:', e
                        #print 'bot sleep: value=', value
                        time.sleep(value)
                        #print 'bot sleep: DONE'
                        result = 'ASLEEP FOR %s SECONDS' % value
                    elif bot_command in ('date', 'time'):
                        result = time.strftime(time_format)
                    elif bot_command == 'uptime':
                        time_t = time.time()
                        time_x = time_t - self.time0
                        time_d = time_x / (60*60*24.)
                        time_h = int(time_x / (60*60))
                        time_s = time_x % 60
                        time_m = int(time_x - time_h*60*60 - time_s)/60
                        result = "Started on: %s\n" % time.asctime(time.localtime(self.time0))
                        result += "%.1d days\n" % (time_d / (60*60*24.0))
                        result += "%d : %02d : %02d hours\n" % (time_h, time_m, time_s)
                        result += "%d seconds\n" % time_x
        return result
    #__END__ commands

# is this file being executed from the command line?
if __name__ == "__main__":
    import logging
    logging.basicConfig(level=logging.ERROR)
    newton = Newton()
    newton.slack()
